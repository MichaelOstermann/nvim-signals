-- Ported from: https://github.com/preactjs/signals/blob/main/packages/core/test/signal.test.tsx
local signal = require("signals.signal")
local effect = require("signals.effect")
local computed = require("signals.computed")
local batch = require("signals.batch")
local spy = require("luassert.spy")

describe("batch", function()
    it("should return the value from the callback", function()
        local result = batch(function()
            return 1
        end)
        assert.are.equal(result, 1)
    end)

    it("should throw errors thrown from the callback", function()
        assert.error_matches(function()
            batch(function()
                error("Whoops")
            end)
        end, "Whoops")
    end)

    it("should delay writes", function()
        local a = signal("a")
        local b = signal("b")
        local cb = spy.new(function()
            return a:get() .. " " .. b:get()
        end)
        effect(cb)
        cb:clear()
        batch(function()
            a:set("aa")
            b:set("bb")
        end)
        assert.spy(cb).was.called(1)
    end)

    it("should delay writes until outermost batch is complete", function()
        local a = signal("a")
        local b = signal("b")
        local cb = spy.new(function()
            return a:get() .. ", " .. b:get()
        end)
        effect(cb)
        cb:clear()
        batch(function()
            batch(function()
                a:set(a:peek() .. " inner")
                b:set(b:peek() .. " inner")
            end)
            a:set(a:peek() .. " outer")
            b:set(b:peek() .. " outer")
        end)
        assert.spy(cb).was.called(1)
    end)

    it("should read signals written to", function()
        local a = signal("a")
        local result = ""
        batch(function()
            a:set("aa")
            result = a:get()
        end)
        assert.are.equal(result, "aa")
    end)

    it("should read computed signals with updated source signals", function()
        local a = signal("a")
        local b = computed(function()
            return a:get()
        end)
        local spyC = spy.new(function()
            return b:get()
        end)
        local c = computed(spyC)
        local spyD = spy.new(function()
            return c:get()
        end)
        local d = computed(spyD)
        local spyE = spy.new(function()
            return d:get()
        end)
        local e = computed(spyE)
        spyC:clear()
        spyD:clear()
        spyE:clear()
        local result = ""
        batch(function()
            a:set("aa")
            result = c:get()
            assert.spy(spyD).was_not_called()
        end)
        assert.are.equal(result, "aa")
        assert.are.equal(d:get(), "aa")
        assert.are.equal(e:get(), "aa")
        assert.spy(spyC).was.called(1)
        assert.spy(spyD).was.called(1)
        assert.spy(spyE).was.called(1)
    end)

    it("should not block writes after batching completed", function()
        local a = signal("a")
        local b = signal("b")
        local c = signal("c")
        local d = computed(function()
            return a:get() .. " " .. b:get() .. " " .. c:get()
        end)
        local result
        effect(function()
            result = d:get()
        end)
        batch(function()
            a:set("aa")
            b:set("bb")
        end)
        c:set("cc")
        assert.are.equal(result, "aa bb cc")
    end)

    it("should not lead to stale signals with :get() in batch", function()
        local invokes = {}
        local counter = signal(0)
        local double = computed(function()
            return counter:get() * 2
        end)
        local triple = computed(function()
            return counter:get() * 3
        end)
        effect(function()
            table.insert(invokes, { double:get(), triple:get() })
        end)
        assert.are.same(invokes, { { 0, 0 } })
        batch(function()
            counter:set(1)
            assert.are.same(double:get(), 2)
        end)
        assert.are.same(invokes[2], { 2, 3 })
    end)

    it("should not lead to stale signals with :peek() in batch", function()
        local invokes = {}
        local counter = signal(0)
        local double = computed(function()
            return counter:get() * 2
        end)
        local triple = computed(function()
            return counter:get() * 3
        end)
        effect(function()
            table.insert(invokes, { double:get(), triple:get() })
        end)
        assert.are.same(invokes, { { 0, 0 } })
        batch(function()
            counter:set(1)
            assert.are.same(double:peek(), 2)
        end)
        assert.are.same(invokes[2], { 2, 3 })
    end)

    it("should run pending effects even if the callback throws", function()
        local a = signal(0)
        local b = signal(1)
        local spy1 = spy.new(function()
            return a:get()
        end)
        local spy2 = spy.new(function()
            return b:get()
        end)
        effect(spy1)
        effect(spy2)
        spy1:clear()
        spy2:clear()
        assert.error_matches(function()
            batch(function()
                a:set(a:peek() + 1)
                b:set(b:peek() + 1)
                error("Whoops")
            end)
        end, "Whoops")
        assert.spy(spy1).was.called(1)
        assert.spy(spy2).was.called(1)
    end)

    it("should run pending effects even if some effects throw", function()
        local a = signal(0)
        local spy1 = spy.new(function()
            return a:get()
        end)
        local spy2 = spy.new(function()
            return a:get()
        end)
        effect(function()
            if a:get() == 1 then
                error("Whoops")
            end
        end)
        effect(spy1)
        effect(function()
            if a:get() == 1 then
                error("Whoops")
            end
        end)
        effect(spy2)
        effect(function()
            if a:get() == 1 then
                error("Whoops")
            end
        end)
        spy1:clear()
        spy2:clear()
        assert.error_matches(function()
            batch(function()
                a:set(a:peek() + 1)
            end)
        end, "Whoops")
        assert.spy(spy1).was.called(1)
        assert.spy(spy2).was.called(1)
    end)

    it("should run effect's first run immediately even inside a batch", function()
        local cb = spy.new(function() end)
        batch(function()
            effect(cb)
        end)
        assert.spy(cb).was.called(1)
    end)
end)
